{
  "Resources":{
    "/package.info.lua":"cmV0dXJuIHsKCiAgICBJbmZvVmVyc2lvbiA9IDEsCgogICAgSUQgPSAiRHVhY29yZC1VdGlscyIsCiAgICBWZXJzaW9uID0gIjEuMC4wIiwKCiAgICBOYW1lID0gIkR1YWNvcmQgVXRpbHRpZXMiLAogICAgRGVzY3JpcHRpb24gPSAiVXRpbGl0aWVzIGZvciBkdWFjb3JkLiBFeHRyYWN0ZWQgZnJvbSBEaXNjb3JkaWEiLAoKICAgIEF1dGhvciA9IHsKICAgICAgICBEZXZlbG9wZXJzID0gewogICAgICAgICAgICAiQ29yZUJ5dGUiCiAgICAgICAgfSwKICAgICAgICBDb250cmlidXRvcnMgPSB7fQogICAgfSwKCiAgICBEZXBlbmRlbmNpZXMgPSB7CiAgICAgICAgTHV2aXQgPSB7fSwKICAgICAgICBEdWEgPSB7fQogICAgfSwKCiAgICBDb250YWN0ID0gewogICAgICAgIFdlYnNpdGUgPSAiaHR0cDovL2R1YWNvcmQuZ2EiLAogICAgICAgIFNvdXJjZSA9ICJodHRwczovL2dpdGh1Yi5jb20vRHVhY29yZC9EdWFjb3JkLVV0aWxzIiwKICAgICAgICBTb2NpYWxzID0gewogICAgICAgICAgICBEaXNjb3JkID0gImh0dHBzOi8vam9pbi5jdWJpYy1pbmMubmwiCiAgICAgICAgfQogICAgfSwKCiAgICBFbnRyeXBvaW50cyA9IHsKICAgICAgICBNYWluID0gImdhLmR1YWNvcmQudXRpbHMuVGVzdC5UZXN0IgogICAgfQoKfQo="
  },
  "PackageInfo":{
    "Dependencies":{
      "Dua":[],
      "Luvit":[]
    },
    "Contact":{
      "Source":"https://github.com/Duacord/Duacord-Utils",
      "Website":"http://duacord.ga",
      "Socials":{
        "Discord":"https://join.cubic-inc.nl"
      }
    },
    "Name":"Duacord Utilties",
    "InfoVersion":1,
    "Entrypoints":{
      "Main":"ga.duacord.utils.Test.Test"
    },
    "Version":"1.0.0",
    "Description":"Utilities for duacord. Extracted from Discordia",
    "Author":{
      "Contributors":[],
      "Developers":["CoreByte"]
    },
    "ID":"Duacord-Utils"
  },
  "Code":{
    "ga.duacord.utils.Date":"--[=[\n@c Date\n@t ui\n@mt mem\n@op seconds number\n@op microseconds number\n@d Represents a single moment in time and provides utilities for converting to\nand from different date and time formats. Although microsecond precision is available,\nmost formats are implemented with only second precision.\n]=]\n\nlocal class = require('class')\nlocal constants = require('constants')\nlocal Time = require('utils/Time')\n\nlocal abs, modf, fmod, floor = math.abs, math.modf, math.fmod, math.floor\nlocal format = string.format\nlocal date, time, difftime = os.date, os.time, os.difftime\nlocal isInstance = class.isInstance\n\nlocal MS_PER_S = constants.MS_PER_S\nlocal US_PER_MS = constants.US_PER_MS\nlocal US_PER_S = US_PER_MS * MS_PER_S\n\nlocal DISCORD_EPOCH = constants.DISCORD_EPOCH\n\nlocal months = {\n\tJan = 1, Feb = 2, Mar = 3, Apr = 4, May = 5, Jun = 6,\n\tJul = 7, Aug = 8, Sep = 9, Oct = 10, Nov = 11, Dec = 12\n}\n\nlocal function offset() -- difference between *t and !*t\n\treturn difftime(time(), time(date('!*t')))\nend\n\nlocal Date = class('Date')\n\nlocal function check(self, other)\n\tif not isInstance(self, Date) or not isInstance(other, Date) then\n\t\treturn error('Cannot perform operation with non-Date object', 2)\n\tend\nend\n\nfunction Date:__init(seconds, micro)\n\n\tlocal f\n\tseconds = tonumber(seconds)\n\tif seconds then\n\t\tseconds, f = modf(seconds)\n\telse\n\t\tseconds = time()\n\tend\n\n\tmicro = tonumber(micro)\n\tif micro then\n\t\tseconds = seconds + modf(micro / US_PER_S)\n\t\tmicro = fmod(micro, US_PER_S)\n\telse\n\t\tmicro = 0\n\tend\n\n\tif f and f > 0 then\n\t\tmicro = micro + US_PER_S * f\n\tend\n\n\tself._s = seconds\n\tself._us = floor(micro + 0.5)\n\nend\n\nfunction Date:__tostring()\n\treturn 'Date: ' .. self:toString()\nend\n\n--[=[\n@m toString\n@op fmt string\n@r string\n@d Returns a string from this Date object via Lua's `os.date`.\nIf no format string is provided, the default is '%a %b %d %Y %T GMT%z (%Z)'.\n]=]\nfunction Date:toString(fmt)\n\tif not fmt or fmt == '*t' or fmt == '!*t' then\n\t\tfmt = '%a %b %d %Y %T GMT%z (%Z)'\n\tend\n\treturn date(fmt, self._s)\nend\n\nfunction Date:__eq(other) check(self, other)\n\treturn self._s == other._s and self._us == other._us\nend\n\nfunction Date:__lt(other) check(self, other)\n\treturn self:toMicroseconds() < other:toMicroseconds()\nend\n\nfunction Date:__le(other) check(self, other)\n\treturn self:toMicroseconds() <= other:toMicroseconds()\nend\n\nfunction Date:__add(other)\n\tif not isInstance(self, Date) then\n\t\tself, other = other, self\n\tend\n\tif not isInstance(other, Time) then\n\t\treturn error('Cannot perform operation with non-Time object')\n\tend\n\treturn Date(self:toSeconds() + other:toSeconds())\nend\n\nfunction Date:__sub(other)\n\tif isInstance(self, Date) then\n\t\tif isInstance(other, Date) then\n\t\t\treturn Time(abs(self:toMilliseconds() - other:toMilliseconds()))\n\t\telseif isInstance(other, Time) then\n\t\t\treturn Date(self:toSeconds() - other:toSeconds())\n\t\telse\n\t\t\treturn error('Cannot perform operation with non-Date/Time object')\n\t\tend\n\telse\n\t\treturn error('Cannot perform operation with non-Date object')\n\tend\nend\n\n--[=[\n@m parseISO\n@t static\n@p str string\n@r number\n@r number\n@d Converts an ISO 8601 string into a Unix time in seconds. For compatibility\nwith Discord's timestamp format, microseconds are also provided as a second\nreturn value.\n]=]\nfunction Date.parseISO(str)\n\tlocal year, month, day, hour, min, sec, other = str:match(\n\t\t'(%d+)-(%d+)-(%d+).(%d+):(%d+):(%d+)(.*)'\n\t)\n\tother = other:match('%.%d+')\n\treturn Date.parseTableUTC {\n\t\tday = day, month = month, year = year,\n\t\thour = hour, min = min, sec = sec, isdst = false,\n\t}, other and other * US_PER_S or 0\nend\n\n--[=[\n@m parseHeader\n@t static\n@p str string\n@r number\n@d Converts an RFC 2822 string (an HTTP Date header) into a Unix time in seconds.\n]=]\nfunction Date.parseHeader(str)\n\tlocal day, month, year, hour, min, sec = str:match(\n\t\t'%a+, (%d+) (%a+) (%d+) (%d+):(%d+):(%d+) GMT'\n\t)\n\treturn Date.parseTableUTC {\n\t\tday = day, month = months[month], year = year,\n\t\thour = hour, min = min, sec = sec, isdst = false,\n\t}\nend\n\n--[=[\n@m parseSnowflake\n@t static\n@p id string\n@r number\n@d Converts a Discord Snowflake ID into a Unix time in seconds. Additional\ndecimal points may be present, though only the first 3 (milliseconds) should be\nconsidered accurate.\n]=]\nfunction Date.parseSnowflake(id)\n\treturn (id / 2^22 + DISCORD_EPOCH) / MS_PER_S\nend\n\n--[=[\n@m parseTable\n@t static\n@p tbl table\n@r number\n@d Interprets a Lua date table as a local time and converts it to a Unix time in\nseconds. Equivalent to `os.time(tbl)`.\n]=]\nfunction Date.parseTable(tbl)\n\treturn time(tbl)\nend\n\n--[=[\n@m parseTableUTC\n@t static\n@p tbl table\n@r number\n@d Interprets a Lua date table as a UTC time and converts it to a Unix time in\nseconds. Equivalent to `os.time(tbl)` with a correction for UTC.\n]=]\nfunction Date.parseTableUTC(tbl)\n\treturn time(tbl) + offset()\nend\n\n--[=[\n@m fromISO\n@t static\n@p str string\n@r Date\n@d Constructs a new Date object from an ISO 8601 string. Equivalent to\n`Date(Date.parseISO(str))`.\n]=]\nfunction Date.fromISO(str)\n\treturn Date(Date.parseISO(str))\nend\n\n--[=[\n@m fromHeader\n@t static\n@p str string\n@r Date\n@d Constructs a new Date object from an RFC 2822 string. Equivalent to\n`Date(Date.parseHeader(str))`.\n]=]\nfunction Date.fromHeader(str)\n\treturn Date(Date.parseHeader(str))\nend\n\n--[=[\n@m fromSnowflake\n@t static\n@p id string\n@r Date\n@d Constructs a new Date object from a Discord/Twitter Snowflake ID. Equivalent to\n`Date(Date.parseSnowflake(id))`.\n]=]\nfunction Date.fromSnowflake(id)\n\treturn Date(Date.parseSnowflake(id))\nend\n\n--[=[\n@m fromTable\n@t static\n@p tbl table\n@r Date\n@d Constructs a new Date object from a Lua date table interpreted as a local time.\nEquivalent to `Date(Date.parseTable(tbl))`.\n]=]\nfunction Date.fromTable(tbl)\n\treturn Date(Date.parseTable(tbl))\nend\n\n--[=[\n@m fromTableUTC\n@t static\n@p tbl table\n@r Date\n@d Constructs a new Date object from a Lua date table interpreted as a UTC time.\nEquivalent to `Date(Date.parseTableUTC(tbl))`.\n]=]\nfunction Date.fromTableUTC(tbl)\n\treturn Date(Date.parseTableUTC(tbl))\nend\n\n--[=[\n@m fromSeconds\n@t static\n@p s number\n@r Date\n@d Constructs a new Date object from a Unix time in seconds.\n]=]\nfunction Date.fromSeconds(s)\n\treturn Date(s)\nend\n\n--[=[\n@m fromMilliseconds\n@t static\n@p ms number\n@r Date\n@d Constructs a new Date object from a Unix time in milliseconds.\n]=]\nfunction Date.fromMilliseconds(ms)\n\treturn Date(ms / MS_PER_S)\nend\n\n--[=[\n@m fromMicroseconds\n@t static\n@p us number\n@r Date\n@d Constructs a new Date object from a Unix time in microseconds.\n]=]\nfunction Date.fromMicroseconds(us)\n\treturn Date(0, us)\nend\n\n--[=[\n@m toISO\n@op sep string\n@op tz string\n@r string\n@d Returns an ISO 8601 string that represents the stored date and time.\nIf `sep` and `tz` are both provided, then they are used as a custom separator\nand timezone; otherwise, `T` is used for the separator and `+00:00` is used for\nthe timezone, plus microseconds if available.\n]=]\nfunction Date:toISO(sep, tz)\n\tif sep and tz then\n\t\tlocal ret = date('!%F%%s%T%%s', self._s)\n\t\treturn format(ret, sep, tz)\n\telse\n\t\tif self._us == 0 then\n\t\t\treturn date('!%FT%T', self._s) .. '+00:00'\n\t\telse\n\t\t\treturn date('!%FT%T', self._s) .. format('.%06i+00:00', self._us)\n\t\tend\n\tend\nend\n\n--[=[\n@m toHeader\n@r string\n@d Returns an RFC 2822 string that represents the stored date and time.\n]=]\nfunction Date:toHeader()\n\treturn date('!%a, %d %b %Y %T GMT', self._s)\nend\n\n--[=[\n@m toSnowflake\n@r string\n@d Returns a synthetic Discord Snowflake ID based on the stored date and time.\nDue to the lack of native 64-bit support, the result may lack precision.\nIn other words, `Date.fromSnowflake(id):toSnowflake() == id` may be `false`.\n]=]\nfunction Date:toSnowflake()\n\tlocal n = (self:toMilliseconds() - DISCORD_EPOCH) * 2^22\n\treturn format('%f', n):match('%d*')\nend\n\n--[=[\n@m toTable\n@r table\n@d Returns a Lua date table that represents the stored date and time as a local\ntime. Equivalent to `os.date('*t', s)` where `s` is the Unix time in seconds.\n]=]\nfunction Date:toTable()\n\treturn date('*t', self._s)\nend\n\n--[=[\n@m toTableUTC\n@r table\n@d Returns a Lua date table that represents the stored date and time as a UTC\ntime. Equivalent to `os.date('!*t', s)` where `s` is the Unix time in seconds.\n]=]\nfunction Date:toTableUTC()\n\treturn date('!*t', self._s)\nend\n\n--[=[\n@m toSeconds\n@r number\n@d Returns a Unix time in seconds that represents the stored date and time.\n]=]\nfunction Date:toSeconds()\n\treturn self._s + self._us / US_PER_S\nend\n\n--[=[\n@m toMilliseconds\n@r number\n@d Returns a Unix time in milliseconds that represents the stored date and time.\n]=]\nfunction Date:toMilliseconds()\n\treturn self._s * MS_PER_S + self._us / US_PER_MS\nend\n\n--[=[\n@m toMicroseconds\n@r number\n@d Returns a Unix time in microseconds that represents the stored date and time.\n]=]\nfunction Date:toMicroseconds()\n\treturn self._s * US_PER_S + self._us\nend\n\n--[=[\n@m toParts\n@r number\n@r number\n@d Returns the seconds and microseconds that are stored in the date object.\n]=]\nfunction Date:toParts()\n\treturn self._s, self._us\nend\n\nreturn Date\n",
    "ga.duacord.utils.Old.Color":"--[=[\n@c Color\n@t ui\n@mt mem\n@p value number\n@d Wrapper for 24-bit colors packed as a decimal value. See the static constructors for more information.\n]=]\n\nlocal class = require('class')\n\nlocal format = string.format\nlocal min, max, abs, floor = math.min, math.max, math.abs, math.floor\nlocal lshift, rshift = bit.lshift, bit.rshift\nlocal band, bor = bit.band, bit.bor\nlocal bnot = bit.bnot\nlocal isInstance = class.isInstance\n\nlocal Color, get = class('Color')\n\nlocal function check(self, other)\n\tif not isInstance(self, Color) or not isInstance(other, Color) then\n\t\treturn error('Cannot perform operation with non-Color object', 2)\n\tend\nend\n\nlocal function clamp(n, mn, mx)\n\treturn min(max(n, mn), mx)\nend\n\nfunction Color:__init(value)\n\tvalue = tonumber(value)\n\tself._value = value and band(value, 0xFFFFFF) or 0\nend\n\nfunction Color:__tostring()\n\treturn format('Color: %s (%i, %i, %i)', self:toHex(), self:toRGB())\nend\n\nfunction Color:__eq(other) check(self, other)\n\treturn self._value == other._value\nend\n\nfunction Color:__add(other) check(self, other)\n\tlocal r = clamp(self.r + other.r, 0, 0xFF)\n\tlocal g = clamp(self.g + other.g, 0, 0xFF)\n\tlocal b = clamp(self.b + other.b, 0, 0xFF)\n\treturn Color.fromRGB(r, g, b)\nend\n\nfunction Color:__sub(other) check(self, other)\n\tlocal r = clamp(self.r - other.r, 0, 0xFF)\n\tlocal g = clamp(self.g - other.g, 0, 0xFF)\n\tlocal b = clamp(self.b - other.b, 0, 0xFF)\n\treturn Color.fromRGB(r, g, b)\nend\n\nfunction Color:__mul(other)\n\tif not isInstance(self, Color) then\n\t\tself, other = other, self\n\tend\n\tother = tonumber(other)\n\tif other then\n\t\tlocal r = clamp(self.r * other, 0, 0xFF)\n\t\tlocal g = clamp(self.g * other, 0, 0xFF)\n\t\tlocal b = clamp(self.b * other, 0, 0xFF)\n\t\treturn Color.fromRGB(r, g, b)\n\telse\n\t\treturn error('Cannot perform operation with non-numeric object')\n\tend\nend\n\nfunction Color:__div(other)\n\tif not isInstance(self, Color) then\n\t\treturn error('Division with Color is not commutative')\n\tend\n\tother = tonumber(other)\n\tif other then\n\t\tlocal r = clamp(self.r / other, 0, 0xFF)\n\t\tlocal g = clamp(self.g / other, 0, 0xFF)\n\t\tlocal b = clamp(self.b / other, 0, 0xFF)\n\t\treturn Color.fromRGB(r, g, b)\n\telse\n\t\treturn error('Cannot perform operation with non-numeric object')\n\tend\nend\n\n--[=[\n@m fromHex\n@t static\n@p hex string\n@r Color\n@d Constructs a new Color object from a hexadecimal string. The string may or may\nnot be prefixed by `#`; all other characters are interpreted as a hex string.\n]=]\nfunction Color.fromHex(hex)\n\treturn Color(tonumber(hex:match('#?(.*)'), 16))\nend\n\n--[=[\n@m fromRGB\n@t static\n@p r number\n@p g number\n@p b number\n@r Color\n@d Constructs a new Color object from RGB values. Values are allowed to overflow\nthough one component will not overflow to the next component.\n]=]\nfunction Color.fromRGB(r, g, b)\n\tr = band(lshift(r, 16), 0xFF0000)\n\tg = band(lshift(g, 8), 0x00FF00)\n\tb = band(b, 0x0000FF)\n\treturn Color(bor(bor(r, g), b))\nend\n\nlocal function fromHue(h, c, m)\n\tlocal x = c * (1 - abs(h / 60 % 2 - 1))\n\tlocal r, g, b\n\tif 0 <= h and h < 60 then\n\t\tr, g, b = c, x, 0\n\telseif 60 <= h and h < 120 then\n\t\tr, g, b = x, c, 0\n\telseif 120 <= h and h < 180 then\n\t\tr, g, b = 0, c, x\n\telseif 180 <= h and h < 240 then\n\t\tr, g, b = 0, x, c\n\telseif 240 <= h and h < 300 then\n\t\tr, g, b = x, 0, c\n\telseif 300 <= h and h < 360 then\n\t\tr, g, b = c, 0, x\n\tend\n\tr = (r + m) * 0xFF\n\tg = (g + m) * 0xFF\n\tb = (b + m) * 0xFF\n\treturn r, g, b\nend\n\nlocal function toHue(r, g, b)\n\tr = r / 0xFF\n\tg = g / 0xFF\n\tb = b / 0xFF\n\tlocal mn = min(r, g, b)\n\tlocal mx = max(r, g, b)\n\tlocal d = mx - mn\n\tlocal h\n\tif d == 0 then\n\t\th = 0\n\telseif mx == r then\n\t\th = (g - b) / d % 6\n\telseif mx == g then\n\t\th = (b - r) / d + 2\n\telseif mx == b then\n\t\th = (r - g) / d + 4\n\tend\n\th = floor(h * 60 + 0.5)\n\treturn h, d, mx, mn\nend\n\n--[=[\n@m fromHSV\n@t static\n@p h number\n@p s number\n@p v number\n@r Color\n@d Constructs a new Color object from HSV values. Hue is allowed to overflow\nwhile saturation and value are clamped to [0, 1].\n]=]\nfunction Color.fromHSV(h, s, v)\n\th = h % 360\n\ts = clamp(s, 0, 1)\n\tv = clamp(v, 0, 1)\n\tlocal c = v * s\n\tlocal m = v - c\n\tlocal r, g, b = fromHue(h, c, m)\n\treturn Color.fromRGB(r, g, b)\nend\n\n--[=[\n@m fromHSL\n@t static\n@p h number\n@p s number\n@p l number\n@r Color\n@d Constructs a new Color object from HSL values. Hue is allowed to overflow\nwhile saturation and lightness are clamped to [0, 1].\n]=]\nfunction Color.fromHSL(h, s, l)\n\th = h % 360\n\ts = clamp(s, 0, 1)\n\tl = clamp(l, 0, 1)\n\tlocal c = (1 - abs(2 * l - 1)) * s\n\tlocal m = l - c * 0.5\n\tlocal r, g, b = fromHue(h, c, m)\n\treturn Color.fromRGB(r, g, b)\nend\n\n--[=[\n@m toHex\n@r string\n@d Returns a 6-digit hexadecimal string that represents the color value.\n]=]\nfunction Color:toHex()\n\treturn format('#%06X', self._value)\nend\n\n--[=[\n@m toRGB\n@r number\n@r number\n@r number\n@d Returns the red, green, and blue values that are packed into the color value.\n]=]\nfunction Color:toRGB()\n\treturn self.r, self.g, self.b\nend\n\n--[=[\n@m toHSV\n@r number\n@r number\n@r number\n@d Returns the hue, saturation, and value that represents the color value.\n]=]\nfunction Color:toHSV()\n\tlocal h, d, mx = toHue(self.r, self.g, self.b)\n\tlocal v = mx\n\tlocal s = mx == 0 and 0 or d / mx\n\treturn h, s, v\nend\n\n--[=[\n@m toHSL\n@r number\n@r number\n@r number\n@d Returns the hue, saturation, and lightness that represents the color value.\n]=]\nfunction Color:toHSL()\n\tlocal h, d, mx, mn = toHue(self.r, self.g, self.b)\n\tlocal l = (mx + mn) * 0.5\n\tlocal s = d == 0 and 0 or d / (1 - abs(2 * l - 1))\n\treturn h, s, l\nend\n\n--[=[@p value number The raw decimal value that represents the color value.]=]\nfunction get.value(self)\n\treturn self._value\nend\n\nlocal function getByte(value, offset)\n\treturn band(rshift(value, offset), 0xFF)\nend\n\n--[=[@p r number The value that represents the color's red-level.]=]\nfunction get.r(self)\n\treturn getByte(self._value, 16)\nend\n\n--[=[@p g number The value that represents the color's green-level.]=]\nfunction get.g(self)\n\treturn getByte(self._value, 8)\nend\n\n--[=[@p b number The value that represents the color's blue-level.]=]\nfunction get.b(self)\n\treturn getByte(self._value, 0)\nend\n\nlocal function setByte(value, offset, new)\n\tlocal byte = lshift(0xFF, offset)\n\tvalue = band(value, bnot(byte))\n\treturn bor(value, band(lshift(new, offset), byte))\nend\n\n--[=[\n@m setRed\n@r nil\n@d Sets the color's red-level.\n]=]\nfunction Color:setRed(r)\n\tself._value = setByte(self._value, 16, r)\nend\n\n--[=[\n@m setGreen\n@r nil\n@d Sets the color's green-level.\n]=]\nfunction Color:setGreen(g)\n\tself._value = setByte(self._value, 8, g)\nend\n\n--[=[\n@m setBlue\n@r nil\n@d Sets the color's blue-level.\n]=]\nfunction Color:setBlue(b)\n\tself._value = setByte(self._value, 0, b)\nend\n\n--[=[\n@m copy\n@r Color\n@d Returns a new copy of the original color object.\n]=]\nfunction Color:copy()\n\treturn Color(self._value)\nend\n\nreturn Color\n",
    "ga.duacord.utils.Mutex":"--[=[\n@c Mutex\n@t ui\n@mt mem\n@d Mutual exclusion class used to control Lua coroutine execution order.\n]=]\n\nlocal Deque = require('./Deque')\nlocal timer = require('timer')\n\nlocal yield = coroutine.yield\nlocal resume = coroutine.resume\nlocal running = coroutine.running\nlocal setTimeout = timer.setTimeout\n\nlocal Mutex = require('class')('Mutex', Deque)\n\nfunction Mutex:__init()\n\tDeque.__init(self)\n\tself._active = false\nend\n\n--[=[\n@m lock\n@op prepend boolean\n@r nil\n@d If the mutex is not active (if a coroutine is not queued), this will activate\nthe mutex; otherwise, this will yield and queue the current coroutine.\n]=]\nfunction Mutex:lock(prepend)\n\tif self._active then\n\t\tif prepend then\n\t\t\treturn yield(self:pushLeft(running()))\n\t\telse\n\t\t\treturn yield(self:pushRight(running()))\n\t\tend\n\telse\n\t\tself._active = true\n\tend\nend\n\n--[=[\n@m unlock\n@r nil\n@d If the mutex is active (if a coroutine is queued), this will dequeue and\nresume the next available coroutine; otherwise, this will deactivate the mutex.\n]=]\nfunction Mutex:unlock()\n\tif self:getCount() > 0 then\n\t\treturn assert(resume(self:popLeft()))\n\telse\n\t\tself._active = false\n\tend\nend\n\n--[=[\n@m unlockAfter\n@p delay number\n@r uv_timer\n@d Asynchronously unlocks the mutex after a specified time in milliseconds.\nThe relevant `uv_timer` object is returned.\n]=]\nlocal unlock = Mutex.unlock\nfunction Mutex:unlockAfter(delay)\n\treturn setTimeout(delay, unlock, self)\nend\n\nreturn Mutex\n",
    "ga.duacord.utils.Time":"--[=[\n@c Time\n@t ui\n@mt mem\n@d Represents a length of time and provides utilities for converting to and from\ndifferent formats. Supported units are: weeks, days, hours, minutes, seconds,\nand milliseconds.\n]=]\n\nlocal class = require('class')\nlocal constants = require('constants')\n\nlocal MS_PER_S    =               constants.MS_PER_S\nlocal MS_PER_MIN  = MS_PER_S    * constants.S_PER_MIN\nlocal MS_PER_HOUR = MS_PER_MIN  * constants.MIN_PER_HOUR\nlocal MS_PER_DAY  = MS_PER_HOUR * constants.HOUR_PER_DAY\nlocal MS_PER_WEEK = MS_PER_DAY  * constants.DAY_PER_WEEK\n\nlocal insert, concat = table.insert, table.concat\nlocal modf, fmod = math.modf, math.fmod\nlocal isInstance = class.isInstance\n\nlocal function decompose(value, mult)\n\treturn modf(value / mult), fmod(value, mult)\nend\n\nlocal units = {\n\t{'weeks', MS_PER_WEEK},\n\t{'days', MS_PER_DAY},\n\t{'hours', MS_PER_HOUR},\n\t{'minutes', MS_PER_MIN},\n\t{'seconds', MS_PER_S},\n\t{'milliseconds', 1},\n}\n\nlocal Time = class('Time')\n\nlocal function check(self, other)\n\tif not isInstance(self, Time) or not isInstance(other, Time) then\n\t\treturn error('Cannot perform operation with non-Time object', 2)\n\tend\nend\n\nfunction Time:__init(value)\n\tself._value = tonumber(value) or 0\nend\n\nfunction Time:__tostring()\n\treturn 'Time: ' .. self:toString()\nend\n\n--[=[\n@m toString\n@r string\n@d Returns a human-readable string built from the set of normalized time values\nthat the object represents.\n]=]\nfunction Time:toString()\n\tlocal ret = {}\n\tlocal ms = self:toMilliseconds()\n\tfor _, unit in ipairs(units) do\n\t\tlocal n\n\t\tn, ms = decompose(ms, unit[2])\n\t\tif n == 1 then\n\t\t\tinsert(ret, n .. ' ' .. unit[1]:sub(1, -2))\n\t\telseif n > 0 then\n\t\t\tinsert(ret, n .. ' ' .. unit[1])\n\t\tend\n\tend\n\treturn #ret > 0 and concat(ret, ', ') or '0 milliseconds'\nend\n\nfunction Time:__eq(other) check(self, other)\n\treturn self._value == other._value\nend\n\nfunction Time:__lt(other) check(self, other)\n\treturn self._value < other._value\nend\n\nfunction Time:__le(other) check(self, other)\n\treturn self._value <= other._value\nend\n\nfunction Time:__add(other) check(self, other)\n\treturn Time(self._value + other._value)\nend\n\nfunction Time:__sub(other) check(self, other)\n\treturn Time(self._value - other._value)\nend\n\nfunction Time:__mul(other)\n\tif not isInstance(self, Time) then\n\t\tself, other = other, self\n\tend\n\tother = tonumber(other)\n\tif other then\n\t\treturn Time(self._value * other)\n\telse\n\t\treturn error('Cannot perform operation with non-numeric object')\n\tend\nend\n\nfunction Time:__div(other)\n\tif not isInstance(self, Time) then\n\t\treturn error('Division with Time is not commutative')\n\tend\n\tother = tonumber(other)\n\tif other then\n\t\treturn Time(self._value / other)\n\telse\n\t\treturn error('Cannot perform operation with non-numeric object')\n\tend\nend\n\n--[=[\n@m fromWeeks\n@t static\n@p t number\n@r Time\n@d Constructs a new Time object from a value interpreted as weeks, where a week\nis equal to 7 days.\n]=]\nfunction Time.fromWeeks(t)\n\treturn Time(t * MS_PER_WEEK)\nend\n\n--[=[\n@m fromDays\n@t static\n@p t number\n@r Time\n@d Constructs a new Time object from a value interpreted as days, where a day is\nequal to 24 hours.\n]=]\nfunction Time.fromDays(t)\n\treturn Time(t * MS_PER_DAY)\nend\n\n--[=[\n@m fromHours\n@t static\n@p t number\n@r Time\n@d Constructs a new Time object from a value interpreted as hours, where an hour is\nequal to 60 minutes.\n]=]\nfunction Time.fromHours(t)\n\treturn Time(t * MS_PER_HOUR)\nend\n\n--[=[\n@m fromMinutes\n@t static\n@p t number\n@r Time\n@d Constructs a new Time object from a value interpreted as minutes, where a minute\nis equal to 60 seconds.\n]=]\nfunction Time.fromMinutes(t)\n\treturn Time(t * MS_PER_MIN)\nend\n\n--[=[\n@m fromSeconds\n@t static\n@p t number\n@r Time\n@d Constructs a new Time object from a value interpreted as seconds, where a second\nis equal to 1000 milliseconds.\n]=]\nfunction Time.fromSeconds(t)\n\treturn Time(t * MS_PER_S)\nend\n\n--[=[\n@m fromMilliseconds\n@t static\n@p t number\n@r Time\n@d Constructs a new Time object from a value interpreted as milliseconds, the base\nunit represented.\n]=]\nfunction Time.fromMilliseconds(t)\n\treturn Time(t)\nend\n\n--[=[\n@m fromTable\n@t static\n@p t table\n@r Time\n@d Constructs a new Time object from a table of time values where the keys are\ndefined in the constructors above (eg: `weeks`, `days`, `hours`).\n]=]\nfunction Time.fromTable(t)\n\tlocal n = 0\n\tfor _, v in ipairs(units) do\n\t\tlocal m = tonumber(t[v[1]])\n\t\tif m then\n\t\t\tn = n + m * v[2]\n\t\tend\n\tend\n\treturn Time(n)\nend\n\n--[=[\n@m toWeeks\n@r number\n@d Returns the total number of weeks that the time object represents.\n]=]\nfunction Time:toWeeks()\n\treturn self:toMilliseconds() / MS_PER_WEEK\nend\n\n--[=[\n@m toDays\n@r number\n@d Returns the total number of days that the time object represents.\n]=]\nfunction Time:toDays()\n\treturn self:toMilliseconds() / MS_PER_DAY\nend\n\n--[=[\n@m toHours\n@r number\n@d Returns the total number of hours that the time object represents.\n]=]\nfunction Time:toHours()\n\treturn self:toMilliseconds() / MS_PER_HOUR\nend\n\n--[=[\n@m toMinutes\n@r number\n@d Returns the total number of minutes that the time object represents.\n]=]\nfunction Time:toMinutes()\n\treturn self:toMilliseconds() / MS_PER_MIN\nend\n\n--[=[\n@m toSeconds\n@r number\n@d Returns the total number of seconds that the time object represents.\n]=]\nfunction Time:toSeconds()\n\treturn self:toMilliseconds() / MS_PER_S\nend\n\n--[=[\n@m toMilliseconds\n@r number\n@d Returns the total number of milliseconds that the time object represents.\n]=]\nfunction Time:toMilliseconds()\n\treturn self._value\nend\n\n--[=[\n@m toTable\n@r number\n@d Returns a table of normalized time values that represent the time object in\na more accessible form.\n]=]\nfunction Time:toTable()\n\tlocal ret = {}\n\tlocal ms = self:toMilliseconds()\n\tfor _, unit in ipairs(units) do\n\t\tret[unit[1]], ms = decompose(ms, unit[2])\n\tend\n\treturn ret\nend\n\nreturn Time\n",
    "ga.duacord.utils.Permissions":"--[=[\n@c Permissions\n@t ui\n@mt mem\n@d Wrapper for a bitfield that is more specifically used to represent Discord\npermissions. See the `permission` enumeration for acceptable permission values.\n]=]\n\nlocal enums = require('enums')\nlocal Resolver = require('client/Resolver')\n\nlocal permission = enums.permission\n\nlocal format = string.format\nlocal band, bor, bnot, bxor = bit.band, bit.bor, bit.bnot, bit.bxor\nlocal sort, insert, concat = table.sort, table.insert, table.concat\n\nlocal ALL = 0\nfor _, value in pairs(permission) do\n\tALL = bor(ALL, value)\nend\n\nlocal Permissions, get = require('class')('Permissions')\n\nfunction Permissions:__init(value)\n\tself._value = tonumber(value) or 0\nend\n\n--[=[\n@m __tostring\n@r string\n@d Defines the behavior of the `tostring` function. Returns a readable list of\npermissions stored for convenience of introspection.\n]=]\nfunction Permissions:__tostring()\n\tif self._value == 0 then\n\t\treturn 'Permissions: 0 (none)'\n\telse\n\t\tlocal a = self:toArray()\n\t\tsort(a)\n\t\treturn format('Permissions: %i (%s)', self._value, concat(a, ', '))\n\tend\nend\n\n--[=[\n@m fromMany\n@t static\n@p ... Permission-Resolvables\n@r Permissions\n@d Returns a Permissions object with all of the defined permissions.\n]=]\nfunction Permissions.fromMany(...)\n\tlocal ret = Permissions()\n\tret:enable(...)\n\treturn ret\nend\n\n--[=[\n@m all\n@t static\n@r Permissions\n@d Returns a Permissions object with all permissions.\n]=]\nfunction Permissions.all()\n\treturn Permissions(ALL)\nend\n\n--[=[\n@m __eq\n@r boolean\n@d Defines the behavior of the `==` operator. Allows permissions to be directly\ncompared according to their value.\n]=]\nfunction Permissions:__eq(other)\n\treturn self._value == other._value\nend\n\nlocal function getPerm(i, ...)\n\tlocal v = select(i, ...)\n\tlocal n = Resolver.permission(v)\n\tif not n then\n\t\treturn error('Invalid permission: ' .. tostring(v), 2)\n\tend\n\treturn n\nend\n\n--[=[\n@m enable\n@p ... Permission-Resolvables\n@r nil\n@d Enables a specific permission or permissions. See the `permission` enumeration\nfor acceptable permission values.\n]=]\nfunction Permissions:enable(...)\n\tlocal value = self._value\n\tfor i = 1, select('#', ...) do\n\t\tlocal perm = getPerm(i, ...)\n\t\tvalue = bor(value, perm)\n\tend\n\tself._value = value\nend\n\n--[=[\n@m disable\n@p ... Permission-Resolvables\n@r nil\n@d Disables a specific permission or permissions. See the `permission` enumeration\nfor acceptable permission values.\n]=]\nfunction Permissions:disable(...)\n\tlocal value = self._value\n\tfor i = 1, select('#', ...) do\n\t\tlocal perm = getPerm(i, ...)\n\t\tvalue = band(value, bnot(perm))\n\tend\n\tself._value = value\nend\n\n--[=[\n@m has\n@p ... Permission-Resolvables\n@r boolean\n@d Returns whether this set has a specific permission or permissions. See the\n`permission` enumeration for acceptable permission values.\n]=]\nfunction Permissions:has(...)\n\tlocal value = self._value\n\tfor i = 1, select('#', ...) do\n\t\tlocal perm = getPerm(i, ...)\n\t\tif band(value, perm) == 0 then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend\n\n--[=[\n@m enableAll\n@r nil\n@d Enables all permissions values.\n]=]\nfunction Permissions:enableAll()\n\tself._value = ALL\nend\n\n--[=[\n@m disableAll\n@r nil\n@d Disables all permissions values.\n]=]\nfunction Permissions:disableAll()\n\tself._value = 0\nend\n\n--[=[\n@m toHex\n@r string\n@d Returns the hexadecimal string that represents the permissions value.\n]=]\nfunction Permissions:toHex()\n\treturn format('0x%08X', self._value)\nend\n\n--[=[\n@m toTable\n@r table\n@d Returns a table that represents the permissions value, where the keys are the\npermission names and the values are `true` or `false`.\n]=]\nfunction Permissions:toTable()\n\tlocal ret = {}\n\tlocal value = self._value\n\tfor k, v in pairs(permission) do\n\t\tret[k] = band(value, v) > 0\n\tend\n\treturn ret\nend\n\n--[=[\n@m toArray\n@r table\n@d Returns an array of the names of the permissions that this object represents.\n]=]\nfunction Permissions:toArray()\n\tlocal ret = {}\n\tlocal value = self._value\n\tfor k, v in pairs(permission) do\n\t\tif band(value, v) > 0 then\n\t\t\tinsert(ret, k)\n\t\tend\n\tend\n\treturn ret\nend\n\n--[=[\n@m union\n@p other Permissions\n@r Permissions\n@d Returns a new Permissions object that contains the permissions that are in\neither `self` or `other` (bitwise OR).\n]=]\nfunction Permissions:union(other)\n\treturn Permissions(bor(self._value, other._value))\nend\n\n--[=[\n@m intersection\n@p other Permissions\n@r Permissions\n@d Returns a new Permissions object that contains the permissions that are in\nboth `self` and `other` (bitwise AND).\n]=]\nfunction Permissions:intersection(other) -- in both\n\treturn Permissions(band(self._value, other._value))\nend\n\n--[=[\n@m difference\n@p other Permissions\n@r Permissions\n@d Returns a new Permissions object that contains the permissions that are not\nin `self` or `other` (bitwise XOR).\n]=]\nfunction Permissions:difference(other) -- not in both\n\treturn Permissions(bxor(self._value, other._value))\nend\n\n--[=[\n@m complement\n@p other Permissions\n@r Permissions\n@d Returns a new Permissions object that contains the permissions that are not\nin `self`, but are in `other` (or the set of all permissions if omitted).\n]=]\nfunction Permissions:complement(other) -- in other not in self\n\tlocal value = other and other._value or ALL\n\treturn Permissions(band(bnot(self._value), value))\nend\n\n--[=[\n@m copy\n@r Permissions\n@d Returns a new copy of the original permissions object.\n]=]\nfunction Permissions:copy()\n\treturn Permissions(self._value)\nend\n\n--[=[@p value number The raw decimal value that represents the permissions value.]=]\nfunction get.value(self)\n\treturn self._value\nend\n\nreturn Permissions\n",
    "ga.duacord.utils.Clock":"--[=[\n@c Clock x Emitter\n@t ui\n@mt mem\n@d Used to periodically execute code according to the ticking of the system clock instead of an arbitrary interval.\n]=]\n\nlocal timer = Timer\n\nlocal date = os.date\nlocal setInterval, clearInterval = timer.setInterval, timer.clearInterval\n\nlocal Clock = Emitter:extend()\n\n--[=[\n@m start\n@op utc boolean\n@r nil\n@d Starts the main loop for the clock. If a truthy argument is passed, then UTC\ntime is used; otherwise, local time is used. As the clock ticks, an event is\nemitted for every `os.date` value change. The event name is the key of the value\nthat changed and the event argument is the corresponding date table.\n]=]\nfunction Clock:Start(utc)\n\tif self._interval then return end\n\tlocal fmt = utc and '!*t' or '*t'\n\tlocal prev = date(fmt)\n\tself._interval = setInterval(1000, function()\n\t\tlocal now = date(fmt)\n\t\tfor k, v in pairs(now) do\n\t\t\tif v ~= prev[k] then\n\t\t\t\tp(k)\n\t\t\t\tself:emit(k, now)\n\t\t\tend\n\t\tend\n\t\tprev = now\n\tend)\nend\n\n--[=[\n@m stop\n@r nil\n@d Stops the main loop for the clock.\n]=]\nfunction Clock:Stop()\n\tif self._interval then\n\t\tclearInterval(self._interval)\n\t\tself._interval = nil\n\tend\nend\n\nreturn Clock\n",
    "ga.duacord.utils.Emitter":"--[=[\n@c Emitter\n@t ui\n@mt mem\n@d Implements an asynchronous event emitter where callbacks can be subscribed to\nspecific named events. When events are emitted, the callbacks are called in the\norder that they were originally registered.\n]=]\n\nlocal timer = require('timer')\n\nlocal wrap, yield = coroutine.wrap, coroutine.yield\nlocal resume, running = coroutine.resume, coroutine.running\nlocal insert, remove = table.insert, table.remove\nlocal setTimeout, clearTimeout = timer.setTimeout, timer.clearTimeout\n\nlocal Emitter = require('class')('Emitter')\n\nfunction Emitter:__init()\n\tself._listeners = {}\nend\n\nlocal function new(self, name, listener)\n\tlocal listeners = self._listeners[name]\n\tif not listeners then\n\t\tlisteners = {}\n\t\tself._listeners[name] = listeners\n\tend\n\tinsert(listeners, listener)\n\treturn listener.fn\nend\n\n--[=[\n@m on\n@p name string\n@p fn function\n@r function\n@d Subscribes a callback to be called every time the named event is emitted.\nCallbacks registered with this method will automatically be wrapped as a new\ncoroutine when they are called. Returns the original callback for convenience.\n]=]\nfunction Emitter:on(name, fn)\n\treturn new(self, name, {fn = fn})\nend\n\n--[=[\n@m once\n@p name string\n@p fn function\n@r function\n@d Subscribes a callback to be called only the first time this event is emitted.\nCallbacks registered with this method will automatically be wrapped as a new\ncoroutine when they are called. Returns the original callback for convenience.\n]=]\nfunction Emitter:once(name, fn)\n\treturn new(self, name, {fn = fn, once = true})\nend\n\n--[=[\n@m onSync\n@p name string\n@p fn function\n@r function\n@d Subscribes a callback to be called every time the named event is emitted.\nCallbacks registered with this method are not automatically wrapped as a\ncoroutine. Returns the original callback for convenience.\n]=]\nfunction Emitter:onSync(name, fn)\n\treturn new(self, name, {fn = fn, sync = true})\nend\n\n--[=[\n@m onceSync\n@p name string\n@p fn function\n@r function\n@d Subscribes a callback to be called only the first time this event is emitted.\nCallbacks registered with this method are not automatically wrapped as a coroutine.\nReturns the original callback for convenience.\n]=]\nfunction Emitter:onceSync(name, fn)\n\treturn new(self, name, {fn = fn, once = true, sync = true})\nend\n\n--[=[\n@m emit\n@p name string\n@op ... *\n@r nil\n@d Emits the named event and a variable number of arguments to pass to the event callbacks.\n]=]\nfunction Emitter:emit(name, ...)\n\tlocal listeners = self._listeners[name]\n\tif not listeners then return end\n\tfor i = 1, #listeners do\n\t\tlocal listener = listeners[i]\n\t\tif listener then\n\t\t\tlocal fn = listener.fn\n\t\t\tif listener.once then\n\t\t\t\tlisteners[i] = false\n\t\t\tend\n\t\t\tif listener.sync then\n\t\t\t\tfn(...)\n\t\t\telse\n\t\t\t\twrap(fn)(...)\n\t\t\tend\n\t\tend\n\tend\n\tif listeners._removed then\n\t\tfor i = #listeners, 1, -1 do\n\t\t\tif not listeners[i] then\n\t\t\t\tremove(listeners, i)\n\t\t\tend\n\t\tend\n\t\tif #listeners == 0 then\n\t\t\tself._listeners[name] = nil\n\t\tend\n\t\tlisteners._removed = nil\n\tend\nend\n\n--[=[\n@m getListeners\n@p name string\n@r function\n@d Returns an iterator for all callbacks registered to the named event.\n]=]\nfunction Emitter:getListeners(name)\n\tlocal listeners = self._listeners[name]\n\tif not listeners then return function() end end\n\tlocal i = 0\n\treturn function()\n\t\twhile i < #listeners do\n\t\t\ti = i + 1\n\t\t\tif listeners[i] then\n\t\t\t\treturn listeners[i].fn\n\t\t\tend\n\t\tend\n\tend\nend\n\n--[=[\n@m getListenerCount\n@p name string\n@r number\n@d Returns the number of callbacks registered to the named event.\n]=]\nfunction Emitter:getListenerCount(name)\n\tlocal listeners = self._listeners[name]\n\tif not listeners then return 0 end\n\tlocal n = 0\n\tfor _, listener in ipairs(listeners) do\n\t\tif listener then\n\t\t\tn = n + 1\n\t\tend\n\tend\n\treturn n\nend\n\n--[=[\n@m removeListener\n@p name string\n@p fn function\n@r nil\n@d Unregisters all instances of the callback from the named event.\n]=]\nfunction Emitter:removeListener(name, fn)\n\tlocal listeners = self._listeners[name]\n\tif not listeners then return end\n\tfor i, listener in ipairs(listeners) do\n\t\tif listener and listener.fn == fn then\n\t\t\tlisteners[i] = false\n\t\tend\n\tend\n\tlisteners._removed = true\nend\n\n--[=[\n@m removeAllListeners\n@p name string/nil\n@r nil\n@d Unregisters all callbacks for the emitter. If a name is passed, then only\ncallbacks for that specific event are unregistered.\n]=]\nfunction Emitter:removeAllListeners(name)\n\tif name then\n\t\tself._listeners[name] = nil\n\telse\n\t\tfor k in pairs(self._listeners) do\n\t\t\tself._listeners[k] = nil\n\t\tend\n\tend\nend\n\n--[=[\n@m waitFor\n@p name string\n@op timeout number\n@op predicate function\n@r boolean\n@r ...\n@d When called inside of a coroutine, this will yield the coroutine until the\nnamed event is emitted. If a timeout (in milliseconds) is provided, the function\nwill return after the time expires, regardless of whether the event is emitted,\nand `false` will be returned; otherwise, `true` is returned. If a predicate is\nprovided, events that do not pass the predicate will be ignored.\n]=]\nfunction Emitter:waitFor(name, timeout, predicate)\n\tlocal thread = running()\n\tlocal fn\n\tfn = self:onSync(name, function(...)\n\t\tif predicate and not predicate(...) then return end\n\t\tif timeout then\n\t\t\tclearTimeout(timeout)\n\t\tend\n\t\tself:removeListener(name, fn)\n\t\treturn assert(resume(thread, true, ...))\n\tend)\n\ttimeout = timeout and setTimeout(timeout, function()\n\t\tself:removeListener(name, fn)\n\t\treturn assert(resume(thread, false))\n\tend)\n\treturn yield()\nend\n\nreturn Emitter\n",
    "ga.duacord.utils.Deque":"--[=[\n@c Deque\n@t ui\n@mt mem\n@d An implementation of a double-ended queue.\n]=]\n\nlocal Deque = require('class')('Deque')\n\nfunction Deque:__init()\n\tself._objects = {}\n\tself._first = 0\n\tself._last = -1\nend\n\n--[=[\n@m getCount\n@r number\n@d Returns the total number of values stored.\n]=]\nfunction Deque:getCount()\n\treturn self._last - self._first + 1\nend\n\n--[=[\n@m pushLeft\n@p obj *\n@r nil\n@d Adds a value of any type to the left side of the deque.\n]=]\nfunction Deque:pushLeft(obj)\n\tself._first = self._first - 1\n\tself._objects[self._first] = obj\nend\n\n--[=[\n@m pushRight\n@p obj *\n@r nil\n@d Adds a value of any type to the right side of the deque.\n]=]\nfunction Deque:pushRight(obj)\n\tself._last = self._last + 1\n\tself._objects[self._last] = obj\nend\n\n--[=[\n@m popLeft\n@r *\n@d Removes and returns a value from the left side of the deque.\n]=]\nfunction Deque:popLeft()\n\tif self._first > self._last then return nil end\n\tlocal obj = self._objects[self._first]\n\tself._objects[self._first] = nil\n\tself._first = self._first + 1\n\treturn obj\nend\n\n--[=[\n@m popRight\n@r *\n@d Removes and returns a value from the right side of the deque.\n]=]\nfunction Deque:popRight()\n\tif self._first > self._last then return nil end\n\tlocal obj = self._objects[self._last]\n\tself._objects[self._last] = nil\n\tself._last = self._last - 1\n\treturn obj\nend\n\n--[=[\n@m peekLeft\n@r *\n@d Returns the value at the left side of the deque without removing it.\n]=]\nfunction Deque:peekLeft()\n\treturn self._objects[self._first]\nend\n\n--[=[\n@m peekRight\n@r *\n@d Returns the value at the right side of the deque without removing it.\n]=]\nfunction Deque:peekRight()\n\treturn self._objects[self._last]\nend\n\n--[=[\n@m iter\n@r function\n@d Iterates over the deque from left to right.\n]=]\nfunction Deque:iter()\n\tlocal t = self._objects\n\tlocal i = self._first - 1\n\treturn function()\n\t\ti = i + 1\n\t\treturn t[i]\n\tend\nend\n\nreturn Deque\n",
    "ga.duacord.utils.Test.Test":"local Package = {}\r\n\r\nfunction Package.OnInitialize()\r\n    local Clock = Import(\"ga.duacord.utils.Clock\")\r\n\r\n    p(Clock)\r\n\r\n    Clock:Start()\r\n    Clock:Stop()\r\n\r\n    Clock:on(\"sec\", p)\r\nend\r\n\r\nreturn Package",
    "ga.duacord.utils.Logger":"--[=[\n@c Logger\n@t ui\n@mt mem\n@p level number\n@p dateTime string\n@op file string\n@d Used to log formatted messages to stdout (the console) or to a file.\nThe `dateTime` argument should be a format string that is accepted by `os.date`.\nThe file argument should be a relative or absolute file path or `nil` if no log\nfile is desired. See the `logLevel` enumeration for acceptable log level values.\n]=]\n\nlocal fs = require('fs')\n\nlocal date = os.date\nlocal format = string.format\nlocal stdout = _G.process.stdout.handle\nlocal openSync, writeSync = fs.openSync, fs.writeSync\n\n-- local BLACK   = 30\nlocal RED     = 31\nlocal GREEN   = 32\nlocal YELLOW  = 33\n-- local BLUE    = 34\n-- local MAGENTA = 35\nlocal CYAN    = 36\n-- local WHITE   = 37\n\nlocal config = {\n\t{'[ERROR]  ', RED},\n\t{'[WARNING]', YELLOW},\n\t{'[INFO]   ', GREEN},\n\t{'[DEBUG]  ', CYAN},\n}\n\ndo -- parse config\n\tlocal bold = 1\n\tfor _, v in ipairs(config) do\n\t\tv[2] = format('\\27[%i;%im%s\\27[0m', bold, v[2], v[1])\n\tend\nend\n\nlocal Logger = require('class')('Logger')\n\nfunction Logger:__init(level, dateTime, file)\n\tself._level = level\n\tself._dateTime = dateTime\n\tself._file = file and openSync(file, 'a')\nend\n\n--[=[\n@m log\n@p level number\n@p msg string\n@p ... *\n@r string\n@d If the provided level is less than or equal to the log level set on\ninitialization, this logs a message to stdout as defined by Luvit's `process`\nmodule and to a file if one was provided on initialization. The `msg, ...` pair\nis formatted according to `string.format` and returned if the message is logged.\n]=]\nfunction Logger:log(level, msg, ...)\n\n\tif self._level < level then return end\n\n\tlocal tag = config[level]\n\tif not tag then return end\n\n\tmsg = format(msg, ...)\n\n\tlocal d = date(self._dateTime)\n\tif self._file then\n\t\twriteSync(self._file, -1, format('%s | %s | %s\\n', d, tag[1], msg))\n\tend\n\tstdout:write(format('%s | %s | %s\\n', d, tag[2], msg))\n\n\treturn msg\n\nend\n\nreturn Logger\n",
    "ga.duacord.utils.Stopwatch":"--[=[\n@c Stopwatch\n@t ui\n@mt mem\n@d Used to measure an elapsed period of time. If a truthy value is passed as an\nargument, then the stopwatch will initialize in an idle state; otherwise, it will\ninitialize in an active state. Although nanosecond precision is available, Lua\ncan only reliably provide microsecond accuracy due to the lack of native 64-bit\ninteger support. Generally, milliseconds should be sufficient here.\n]=]\n\nlocal hrtime = require('uv').hrtime\nlocal constants = require('constants')\nlocal Time = require('utils/Time')\n\nlocal format = string.format\n\nlocal MS_PER_NS = 1 / (constants.NS_PER_US * constants.US_PER_MS)\n\nlocal Stopwatch, get = require('class')('Stopwatch')\n\nfunction Stopwatch:__init(stopped)\n\tlocal t = hrtime()\n\tself._initial = t\n\tself._final = stopped and t or nil\nend\n\n--[=[\n@m __tostring\n@r string\n@d Defines the behavior of the `tostring` function. Returns a string that\nrepresents the elapsed milliseconds for convenience of introspection.\n]=]\nfunction Stopwatch:__tostring()\n\treturn format('Stopwatch: %s ms', self.milliseconds)\nend\n\n--[=[\n@m stop\n@r nil\n@d Effectively stops the stopwatch.\n]=]\nfunction Stopwatch:stop()\n\tif self._final then return end\n\tself._final = hrtime()\nend\n\n--[=[\n@m start\n@r nil\n@d Effectively starts the stopwatch.\n]=]\nfunction Stopwatch:start()\n\tif not self._final then return end\n\tself._initial = self._initial + hrtime() - self._final\n\tself._final = nil\nend\n\n--[=[\n@m reset\n@r nil\n@d Effectively resets the stopwatch.\n]=]\nfunction Stopwatch:reset()\n\tself._initial = self._final or hrtime()\nend\n\n--[=[\n@m getTime\n@r Time\n@d Returns a new Time object that represents the currently elapsed time. This is\nuseful for \"catching\" the current time and comparing its many forms as required.\n]=]\nfunction Stopwatch:getTime()\n\treturn Time(self.milliseconds)\nend\n\n--[=[@p milliseconds number The total number of elapsed milliseconds. If the\nstopwatch is running, this will naturally be different each time that it is accessed.]=]\nfunction get.milliseconds(self)\n\tlocal ns = (self._final or hrtime()) - self._initial\n\treturn ns * MS_PER_NS\nend\n\nreturn Stopwatch\n"
  }
}